"""
    Items and spawning:
    
    In my understanding, item prototypes will write over arbitrary non-category attributes.
    That means that any type expecting to be spawned needs to read its attributes into
    class variables, which I suppose is normal for evennia.
"""

from .item import Item
from .objects import Object,SpawnerObject
from util.AttrProperty import AttributeProperty
from random import choices
from util.random import prob
from evennia.utils.dbserialize import _SaverDict
from .characters import Character

class SpawnPicker:
    """
        Helper object that accepts a string, None, or formatted list.
        When called, it will return a result specified by the origin.
        If the input is:
        * "", [], {}, or 0:
            Returns [ None ]
        * string or [ string ]
            Return [ string ] 
        * [ stringA, stringB, ...]
            Return random [ string] 
        * { stringA:weightA, stringB:weightB }
            Return random [ string ], weighted probability
        If the call function is passed a high count, this is repeated with replacement
        as per random choices()
    """
    def __init__(self, incoming):
        if incoming == 0 or len(incoming) == 0:
            self.opts=[None]
            self.weights= None
            return
        elif isinstance(incoming,str):
            self.opts = [incoming]
            self.weights = None
        elif isinstance(incoming, list):
            self.opts = incoming
            self.weights = None
        elif isinstance(incoming, dict) or isinstance(incoming,_SaverDict):
            self.opts = [*incoming.keys()]
            self.weights = [*incoming.values()]
        else:
            raise ValueError(f"SpawnPicker: Unrecognized chunk {incoming} ({type(incoming)})")
        # In case the key we are given is a comma-separated list, split them now
        # This should be passed to SpawnerObject.spawn() which accepts lists of keys
        # In this specific case I strip whitespace around commas for readability
        # But I do not normally strip whitespace
        for i in range(0,len(self.opts)):
            if isinstance(self.opts[i],str) and self.opts[i].count(",") > 0:
                self.opts[i] = [*map(lambda s:s.strip(),self.opts[i])]
        #print(f"{incoming} -> {self.opts},{self.weights}")
    def __call__(self,count=1):
        return choices(self.opts,self.weights,k=count)

class ResourceNode(SpawnerObject):
    """
    A Resource Node generates items from prototypes.  These are intended for use with
    forage-type skills, and may be automatically generated by a room.
    Nodes have one or more resource types, and may randomly run out of resources.
    
    The format for a resource dict is
    { tier: proto_key, ... } for single guaranteed drop per tier
     or
    { tier: [ proto_key, ... ], ... } for random unweighted drop per tier
     or
    { tier: [ [ proto_key, weight], ... ], ... } for random weighted drop per tier
    
    The active tier is the closest tier not higher than the result.
    Proto keys with an empty string are a non-event.
    Proto keys containing a comma will be split on commas and trimmed of whitespace.
    
    The rare and trash dicts translate common resource prototype keys into
    boosted or penalized versions of the same.  If the result is a list,
    it is treated identically as resource dict 
    """
    skill_key = "forage"
    nominal_tier = AttributeProperty("nominal_tier",2)
    min_tier = AttributeProperty("min_tier",1)
    max_tier = AttributeProperty("max_tier",3)
    resdata=AttributeProperty("resources")
    resources={}
    rare_chance = AttributeProperty("rare_chance",0)
    rare=AttributeProperty("rare",{})
    trash_chance=AttributeProperty("trash_chance",0)
    trash=AttributeProperty("trash",{})
    seen_by=AttributeProperty("seen_by",[])
    finished_prob = AttributeProperty("finished_prob",15)
    parsed=None
    giver = True
    
    def seen(self,user):
        if user != None:
            return self.seen_by.count(user.dbref)
    
    def forage(self,user,skill,result):
        if not isinstance(user,Character):
            return
        if skill.key != self.skill_key:
            return
        if not self.seen_by.count(user.dbref):
            if (result >= self.max_tier and prob(66)) or (result >= self.nominal_tier and prob(45)) or prob(25):
                user.msg(f"You discover a |w{self}|n!")
                self.seen_by.append(user.dbref)
            else:
                user.msg(f"You search around for a while.")
            return
        result = self.random_spawn(user,result)
        if (not result and prob(self.finished_prob)) or prob(self.finished_prob):
            user.msg(f"The |w{self}|n looks to be spent.")
            self.seen_by.remove(user.dbref)
            return True
        return result != None and result != []
    
    def at_init(self):
        for tier,opts in self.resdata.items():
            self.resources[int(tier)] = SpawnPicker(opts)
        lr = None
        for tier in range(self.min_tier,self.max_tier+1):
            if not tier in self.resources:
                self.resources[tier] = lr or SpawnPicker("")

    
    def random_spawn(self,user,result_tier):
        if not isinstance(result_tier,int):
            raise ValueError(f"ResourceNode.random_spawn: result_tier must be int")
        if result_tier < self.min_tier:
            return None
        if result_tier > self.max_tier:
            result_tier = self.max_tier
        spawner = self.resources[result_tier]
        if not isinstance(spawner,SpawnPicker):
            raise IndexError("What?")

        result = spawner()
        print(result)
        if len(self.rare) > 0 and self.rare_chance > 0:
            if (result_tier >= self.nominal_tier and prob(self.rare_chance)) or (result_tier == self.max_tier and prob(self.rare_chance)):
                nr=[]
                for i in result:
                    if i in self.rare:
                        t=self.rare[i]
                        if isinstance(t,list):
                            nr.extend(t)
                        elif isinstance(t,SpawnPicker):
                            t=t()
                            if t[0] != None:
                                nr.extend(t)
                        else:
                            nr.append(t)
                    else:
                        nr.append(i)
                result=nr
        if len(self.trash) > 0 and self.trash_chance > 0:
            if (result_tier < self.nominal_tier and prob(self.trash_chance)) or (result_tier == self.min_tier and prob(self.trash_chance)):
                pass
        
        if len(result) == 1 and (result[0] == None or result[0] == ""):
            return None
        print(result)
        return self.spawn(result,user) # see objects.dm for SpawnerObject.spawn

class Resource(Item):
    """
        A Resource object is specifically something intended for crafting or selling.
        Resources are tagged by type and quality and may later have other stuff for stuff.
        
        Resources have quality, quantity, and type essence, and bonus essence.
        Type essences are implicit from the type, are subtyped, and can be multiple.
        For example, plant.flower.rose.stonerose,rock.marble.  All subtypes can be
        used in place of a parent, like rock.marble being used for any alchemy requiring rock.
        
        Bonus essences are for rare subtypes.  For example, a "magma rose" might be
        a marble-type stone rose with added fire.magma bonus essence.  Rare subtypes
        can be used as though they were a standard resource of that type.
    """
    quality=AttributeProperty("quality",50)
    pass