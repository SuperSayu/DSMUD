"""
    Items and spawning:
    
    In my understanding, item prototypes will write over arbitrary non-category attributes.
    That means that any type expecting to be spawned needs to read its attributes into
    class variables, which I suppose is normal for evennia.
"""

from .item import Item
from .objects import Object
from .SceneObject import SpawnerObject
from util.AttributeProperty import AttributeProperty
from random import choices
from util.random import prob
from evennia.utils.dbserialize import _SaverDict
from .characters import Character
from util.spawn import spawn

class SpawnPicker:
    """
        Helper object that accepts a string, None, or formatted list or dict.
        When called, it will return a random result from those options.
        If the input is:
        * "", [], {}, or 0:
            Returns [ None ]
        * string or [ string ]
            Return [ string ] 
        * [ stringA, stringB, ...]
            Return random [ string ] 
        * { stringA:weightA, stringB:weightB }
            Return random [ string ], weighted probability
        If the call function is passed a high count, this is repeated with replacement
        as per random choices(), eg, [ stringB, stringB, stringA ]
        
        If the string input is a comma separated list, the returned result will be
        an array of strings with whitespace stripped.
    """
    def __init__(self, incoming):
        if incoming == 0 or len(incoming) == 0:
            self.opts=[None]
            self.weights= None
            return
        elif isinstance(incoming,str):
            self.opts = [incoming]
            self.weights = None
        elif isinstance(incoming, list):
            self.opts = incoming
            self.weights = None
        elif isinstance(incoming, dict) or isinstance(incoming,_SaverDict):
            self.opts = [*incoming.keys()]
            self.weights = [*incoming.values()]
        else:
            raise ValueError(f"SpawnPicker: Unrecognized chunk {incoming} ({type(incoming)})")
        # In case the key we are given is a comma-separated list, split them now
        # This should be passed to SpawnerObject.spawn() which accepts lists of keys
        # In this specific case I strip whitespace around commas for readability
        # But I do not normally strip whitespace
        for i in range(0,len(self.opts)):
            if isinstance(self.opts[i],str) and self.opts[i].count(",") > 0:
                self.opts[i] = [*map(lambda s:s.strip(),self.opts[i])]
        #print(f"{incoming} -> {self.opts},{self.weights}")
    def __call__(self,count=1):
        return choices(self.opts,self.weights,k=count)
    def detect_opt_error(self,i):
        o = self.opts[i]
        if isinstance(o,str):
            return ""
        if isinstance(o,list):
            for x in o:
                if not isinstance(x,str):
                    return "! Non-string index {x}"
            return ""
        if o == 0 or o == None or o == {}:
            return "! Improper none should be empty str"
        return "! Unknown option format"
    def detect_weight_error(self,i):
        if not isinstance(i,int) and not isinstance(i,float):
            return "! Non-number weight"
        if i < 0:
            return "! Negative weight"
        return ""
    def show(self):
        if self.weights:
            temp=[]
            for i in range(0,len(self.opts)):
                o = self.opts[i] or "<NONE>"
                temp.append(f"{o}{self.detect_opt_error(i)}:{self.weights[i]}{self.detect_weight_error(i)}")
            return f"Weighted [{','.join(temp)}]"
        else:
            temp=[]
            for i in range(0,len(self.opts)):
                temp.append(f"{self.opts[i]}{self.detect_opt_error(i)}")
            return f"Unweighted [{','.join(temp)}]"

class ResourceNode(SpawnerObject):
    """
    A Resource Node generates items from prototypes.  These are intended for use with
    forage-type skills, and may be automatically generated by a room.
    Nodes have one or more resource types, and may randomly run out of resources.
    
    The format for a resource dict is
    { tier: proto_key, ... } for single guaranteed drop per tier
     or
    { tier: [ proto_key, ... ], ... } for random unweighted drop per tier
     or
    { tier: [ [ proto_key, weight], ... ], ... } for random weighted drop per tier
    
    Empty string proto keys are a non-event.  Unlisted tiers copy the next lower specified tier.
    Proto keys containing a comma will be split on commas and trimmed of whitespace.
    
    The rare and trash dicts translate common resource prototype keys into
    boosted or penalized versions of the same.  If the result is a list,
    it is treated identically as resource dict 
    """
    LongSceneVars=["desc","seen_desc","unseen_desc"] # these are used by the Scene verb for viewing and editing
    # new Attribute Properties
    skill_key       = AttributeProperty("forage")
    min_tier        = AttributeProperty(1)
    nominal_tier    = AttributeProperty(2)
    max_tier        = AttributeProperty(3)
    
    resdata         = AttributeProperty({},key="resources")     # Resource dict per SpawnPicker
    rare_chance     = AttributeProperty(0)    # Chance of mutation, only if meeting nominal tier, more if max tier
    raredata        = AttributeProperty({},key="rare")          # commonkey:rarekey dict
    trash_chance    = AttributeProperty(0)   # Chance of mutation, only if below nominal tier, more if min tier
    trashdata       = AttributeProperty({},key="trash")         # commonkey:trashkey dict
    seen_by         = AttributeProperty([])       # Forage: force resource searchers to find a node first
    finished_prob   = AttributeProperty(15) # Forage: exhaust nodes, per searcher

    seen_desc       = AttributeProperty("") # Background text for if this resource node has been discovered
    unseen_desc     = AttributeProperty("") # Background text for if this resource node has not been discovered.
    
    # Changed Attribute Properties
    giver = True # tc/objects:SpawnerObject
    
    # Pure pythonic variables
    # These are used to hold SpawnPickers
    resources={}
    rare = {}
    trash = {}
    
    

    def get_background_desc(self, looker, state=None, **kwargs):
        if not self.access(looker,"bgview") or self.invisible:
            return ""
        if self.Seen(looker):
            return self.seen_desc
        else:
            return self.unseen_desc

    def Seen(self,user):
        if user != None:
            return self.seen_by.count(user.dbref) > 0
        return False
    
    def forage(self,user,skill,result):
        if not isinstance(user,Character):
            return
        if skill.key != self.skill_key:
            return
        if not self.seen_by.count(user.dbref):
            if (result >= self.max_tier and prob(66)) or (result >= self.nominal_tier and prob(45)) or prob(25):
                user.msg(f"You discover a |w{self}|n!")
                self.seen_by.append(user.dbref)
            else:
                user.msg(f"You search around for a while.")
            return
        result = self.random_spawn(user,result)
        if (not result and prob(self.finished_prob)) or prob(self.finished_prob):
            user.msg(f"The |w{self}|n looks to be spent.")
            self.seen_by.remove(user.dbref)
            return True
        return result != None and result != []
    
    def at_post_spawn(self,caller=None,spawner=None):
        self.at_init()
        
    def at_init(self):
        if len(self.resources):
            self.resources={}
            self.rare={}
            self.trash={}
        if len(self.resdata) == 0: # Attributes not yet loaded or nothing to initialize
            return
        for tier,opts in self.resdata.items():
            self.resources[int(tier)] = SpawnPicker(opts)
        lr = None
        for tier in range(self.min_tier,self.max_tier+1):
            if not tier in self.resources:
                self.resources[tier] = lr or SpawnPicker("")
            else:
                lr = self.resources[tier]
        for key,result in self.raredata.items():
            self.rare[key]=SpawnPicker(result)
        for key,result in self.trashdata.items():
            self.trash[key]=SpawnPicker(result)

    def test(self):
        print(f"{self}({self.__class__.__name__}) self-test:")
        lt=-1
        for tier in range(self.min_tier,self.max_tier+1):
            exists=(tier in self.resources)
            isnew=False
            s=str(tier)
            if s in self.resdata.keys():
                isNew = True
                lt = tier
                print(f"[At tier {tier}]")
                print(f"> From {self.resdata[s]}")
                if exists:
                    print(f"> {self.resources[tier].show()}")
                else:
                    print(f"> !MISSING")
            else:
                print(f"[At tier {tier}]")
                print(f"> Inherited")
                if exists:
                    print(f"> {self.resources[tier].show()}")
                else:
                    print(f"> !MISSING")
    def test_spawn(self,user=None,level=None):
        if level == None:
            level = self.nominal_tier
        objs=self.random_spawn(user,level)
        
    
    def random_spawn(self,user,result_tier):
        if not isinstance(result_tier,int):
            raise ValueError(f"ResourceNode.random_spawn: result_tier must be int")
        if result_tier < self.min_tier:
            return None
        if result_tier > self.max_tier:
            result_tier = self.max_tier
        spawner = self.resources[result_tier]
        if not isinstance(spawner,SpawnPicker):
            raise IndexError("What?")

        result = spawner()
        if len(self.rare) > 0 and self.rare_chance > 0:
            if (result_tier >= self.nominal_tier and prob(self.rare_chance)) or (result_tier == self.max_tier and prob(self.rare_chance)):
                nr=[]
                for i in result:
                    if i in self.rare:
                        t=self.rare[i]
                        if isinstance(t,list):
                            nr.extend(t)
                        elif isinstance(t,SpawnPicker):
                            t=t()
                            if t[0] != None:
                                nr.extend(t)
                        else:
                            nr.append(t)
                    else:
                        nr.append(i)
                result=nr
        if len(self.trash) > 0 and self.trash_chance > 0:
            if (result_tier < self.nominal_tier and prob(self.trash_chance)) or (result_tier == self.min_tier and prob(self.trash_chance)):
                pass
        
        if len(result) == 1 and (result[0] == None or result[0] == ""):
            return None
        return spawn(result, caller=user, spawner=self, location=self.location) # util.spawn.spawn()

class Resource(Item):
    _content_types = ("object","item","resource",)
    """
        A Resource object is specifically something intended for crafting or selling.
        Resources are tagged by type and quality and may later have other stuff for stuff.
        
        Resources have quality, quantity, and type essence, and bonus essence.
        Type essences are implicit from the type, are subtyped, and can be multiple.
        For example, plant.flower.rose.stonerose,rock.marble.  All subtypes can be
        used in place of a parent, like rock.marble being used for any alchemy requiring rock.
        
        Bonus essences are for rare subtypes.  For example, a "magma rose" might be
        a marble-type stone rose with added fire.magma bonus essence.  Rare subtypes
        can be used as though they were a standard resource of that type.
    """
    quality=AttributeProperty(50)
    pass